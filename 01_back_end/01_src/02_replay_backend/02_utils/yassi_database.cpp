#include "yassi_database.hpp"

using namespace Yassi::Backend::Replay;
using namespace Yassi::Utils;

/**
 * @brief Constructor
 * 
 * @param url: Location of the Database
 */
Database::Database(std::string const & url):
    BaseDatabase(url)
{
    p_db_url = url;
    p_debug = false;
}

/**
 * @brief Destructor
 */ 
Database::~Database()
{
    /* Nothing to clean up here :) */
}

/**
 * @brief Callback function used by the Sqlite3 API - has access to the this pointer
 * 
 * The azColName parameter is unused - since the interface is predefined we told GCC 
 * to ignore this.
 */ 
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
int Database::__callback__(int argc, char **argv, char **azColName)
{
#pragma GCC diagnostic pop
    if (*argv == nullptr){
        // If the Table is empty we receive a nullptr
        return 0;
    } else {
        if (p_active_transaction == e_init){
            // Chill dude
        } else if (p_active_transaction == e_verbose){
            // Maybe print it to stdout
        } else if (p_active_transaction == e_get_test_vector_variables){
            VariableInfo var;
            var.name = argv[0];
            var.position = argv[2];
            var.type = argv[1];
            var.free = std::stoi(argv[3]);
            p_test_vector_variables.push_back(var);
        } else if (p_active_transaction == e_options){
            p_options[argv[0]] = argv[1];
        } else if (p_active_transaction == e_test_vectors){
            TestVector v;
            v.value = argv[0];
            v.variable_name = argv[1];
            v.variable_hint = argv[2];
            v.value = argv[3];
            p_test_vectors.push_back(v);
        } else if (p_active_transaction == e_get_bb){
            BasicBlock bb;
            bb.file = argv[0];
            bb.fn = argv[1];
            bb.bb = argv[2];
            p_basic_blocks.push_back(bb);
        } else {
            throw YassiException("Invalid transaction!");
        }
        return 0;
    }
}

/**
 * @brief Read Stored Options from the Database
 * 
 * @return std::map< std::string, std::string >
 */
std::map<std::string, std::string> Database::get_options()
{
    std::stringstream query;
    query << "SELECT * FROM options;";
    
    p_active_transaction = e_options;
    this->db_command(query.str());
    p_active_transaction = e_init;
    
    return p_options;
}

/**
 * @brief Read Variables used in Testvectors from the Database
 * 
 * @return std::vector< Yassi::VariableInfo >
 */
std::vector<VariableInfo> Database::get_test_vector_variables()
{
    p_test_vector_variables.clear();
    
    std::string query = "SELECT * from variables where variables.name in (select name from results);";
   
    p_active_transaction = e_get_test_vector_variables;
    this->db_command(query);
    p_active_transaction = e_init;
 
    return p_test_vector_variables;
}

/**
 * @brief Get Testvectors from the Database
 * 
 * @return std::vector< Yassi::TestVector >
 */
std::vector<TestVector> Database::get_test_vectors()
{
    std::string query = "SELECT * from minimal_vectors;";
    p_test_vectors.clear();
    
    p_active_transaction = e_test_vectors;
    this->db_command(query);
    p_active_transaction = e_init;
    
    return p_test_vectors;
}

/**
 * @brief Get used BasicBlocks from the Database
 */
std::vector<BasicBlock> Database::get_basic_blocks()
{
    p_basic_blocks.clear();
    std::string query = "SELECT * from basic_blocks;";
    
    p_active_transaction = e_get_bb;
    this->db_command(query);
    p_active_transaction = e_init;
    
    return p_basic_blocks;
}

/**
* @brief Insert a measurement entry
* 
* @param name: Type name
* @param value: Measurement Value
*/
void Database::insert_measurement(std::string name, std::string value)
{
	std::stringstream action;

	action << "insert into measurements values ('" << name << "','" << value << "');";
    this->db_command(action.str());
}

/**
 * @brief Insert the execution trace generated by the replay measurement
 * TODO Maybe add the problem number to the trace?
 * 
 * @param paths p_paths: The vector containing the names of all functions, basicblocks called sorted
 */
void Database::insert_measurement_trace(const std::vector<std::string>& paths) 
{
    std::string functions_and_bbs_s;
   
	for(auto it : paths){
		functions_and_bbs_s += it + ",";
	}

	std::stringstream action;
	action << "insert into measurement_trace values ('" << functions_and_bbs_s << "');";
    
    this->db_command(action.str());
}

/**
 * @brief Insert a visited BasicBlock into the Database
 * 
 * @param file: File containing the BasicBlock
 * @param fn: Function holding the BasicBlock
 * @param bb: Name of the BasicBlock
 */
void Database::insert_basic_block(std::string const & file, std::string const & fn, std::string const & bb)
{
    std::stringstream query;
    query << "INSERT INTO replay_basic_blocks (file, function, bb) values ('" << file << "','" << fn << "','" << bb << "');";
    
    this->db_command(query.str());
}
