/** 
 * @file yassi_resultschecker.cpp
 * @brief Check the results generated by Yassi
 * 
 * Yassi Implements Symbolic Execution on the LLVM IR and is able
 * to explore designs in C/C++ including Assertion Checking, Test Generation
 *
 * Copyright (C) 2019 Johannes Kepler University
 * @author Sebastian Pointner
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
#include "yassi_resultchecker.hpp"

using namespace Yassi::Utils;

ResultChecker::ResultChecker(std::string const & project_url, std::string const & tmp_url):
    p_tmp_url(tmp_url),
    p_project_url(project_url)
{
    p_result_identifier = "result";
    p_exception_identifier = "exception";
    p_seperation_token = "_";

    p_database = new Frontend::Database(tmp_url + "/db/database.db");
}

ResultChecker::~ResultChecker()
{
    delete p_database;    p_database = nullptr;
}

void ResultChecker::read_golden_results_file()
{
    p_golden_exceptions.clear();
    p_golden_results.clear();
    
    std::string gold_result = p_project_url + "/gold_result.json";

    if(boost::filesystem::exists(gold_result)) {
        Json::Value root;
        std::ifstream gold_file(gold_result);
        gold_file >> root;
        gold_file.close();

        for(auto itor = root.begin(); itor != root.end(); ++itor) {
            std::string identifier = itor->begin().key().asString();
            std::vector<std::string> token = BaseUtils::tokenize(identifier, p_seperation_token);

            if(token.front() == p_result_identifier) {
                for(auto itor2 = itor->begin(); itor2 != itor->end(); ++itor2) {
                    SingleResultPair tmp;
                    for (auto itor3 = itor2->begin(); itor3 != itor2->end(); ++itor3) {
                        if(itor3.key().asString() == "solution") {
                            tmp.solution = itor3->asInt();
                        } else if (itor3.key().asString() == "name") {
                            tmp.reg_name = itor3->asString();
                        } else if (itor3.key().asString() == "hint") {
                            tmp.reg_hint = itor3->asString();
                        } else if (itor3.key().asString() == "value") {
                            tmp.reg_val = itor3->asString();
                        } else {
                            throw YassiException("Unknown JSON Key Found! (Result Entry: " + itor3.key().asString() + ")");
                        }
                    }
                    p_golden_results.push_back(tmp);
                }
            } else if (token.front() == p_exception_identifier) {
                for(auto itor2 = itor->begin(); itor2 != itor->end(); ++itor2) {
                    SingleException tmp;
                    for (auto itor3 = itor2->begin(); itor3 != itor2->end(); ++itor3) {
                        if(itor3.key().asString() == "file") {
                            tmp.file = itor3->asString();
                        } else if (itor3.key().asString() == "id") {
                            tmp.id = itor3->asString();
                        } else if (itor3.key().asString() == "location") {
                            tmp.location = itor3->asString();
                        } else if (itor3.key().asString() == "type") {
                            tmp.type = itor3->asString();
                        } else {
                            throw YassiException("Unknown JSON Key Found! (Exception Entry: " + itor3.key().asString() + ")");
                        }
                    }
                    p_golden_exceptions.push_back(tmp);
                }
            } else {
                throw YassiException("Unknown Golden Type Detected! (Neither Result nor Exception)");
            }
        }
    }
}

eCmpStatus ResultChecker::check_results()
{    
    this->read_golden_results_file();

    std::vector<SingleResultPair> current_results = p_database->get_results();
    std::vector<SingleException> current_exceptions = p_database->get_exceptions();
    
    eCmpStatus result = eINIT;
    
    if(!p_golden_exceptions.empty() || !p_golden_results.empty()){
        
        // Case 1: There are no results but there is a non empty Gold Result
        if(current_results.empty() && (!p_golden_results.empty() || !p_golden_exceptions.empty())){
            result = eFAIL;
         // Case 2: There are no results and there is an empty Gold Result
        } else if (current_results.empty() && p_golden_results.empty() && p_golden_exceptions.empty()){
           result = eSUCCESS;
        // Case 3: There are Results and there is a non empty Gold Result
             
        } else if(!current_exceptions.empty() && !current_results.empty() && !p_golden_exceptions.empty() && !p_golden_results.empty()){
            // There are exceptions and results in the database as well as in the golden results file
            if(std::equal(current_results.begin(), current_results.end(), p_golden_results.begin()) &&
                std::equal(current_exceptions.begin(), current_exceptions.end(), p_golden_exceptions.begin())){
               result = eSUCCESS;
            } else {
               result = eFAIL;
            }
        } else if (current_exceptions.empty() && !current_results.empty() && p_golden_exceptions.empty() && !p_golden_results.empty()) {
            // There are result in the database and in the golden file but no exceptions
            if(std::equal(current_results.begin(), current_results.end(), p_golden_results.begin())){
               result = eSUCCESS;
            } else {
               result = eFAIL;
            }
        }
    } else {
        // Case 4 There is no Gold Result File
        if(!current_results.empty() && get_golden_results().empty()){
            result = eUnknown;
        } else if (current_results.empty() && p_golden_results.empty()){
            result = eSUCCESS;
        }
    }
    return result;
}

std::vector<SingleException> ResultChecker::get_golden_exceptions()
{
    this->read_golden_results_file();
    
    return p_golden_exceptions;
}

std::vector<SingleResultPair> ResultChecker::get_golden_results()
{
    this->read_golden_results_file();
    
    return p_golden_results;
}

void ResultChecker::write_golden_results()
{
    std::vector<SingleResultPair> current_results = p_database->get_results();
    std::vector<SingleException> current_exceptions = p_database->get_exceptions();

    std::fstream out_file(p_project_url + "/gold_result.json", std::ios::out);
    Json::Value root;
    size_t id = 0;
    
    for(auto& result : current_results){
        Json::Value tmp;
    
        tmp[p_result_identifier + p_seperation_token + std::to_string(id)]["hint"]     = result.reg_hint;
        tmp[p_result_identifier + p_seperation_token + std::to_string(id)]["value"]    = result.reg_val;
        tmp[p_result_identifier + p_seperation_token + std::to_string(id)]["solution"] = result.solution;
        tmp[p_result_identifier + p_seperation_token + std::to_string(id)]["name"]     = result.reg_name;
     
        root.append(tmp);
        id++;
    }
   
    for(auto& exception : current_exceptions){
        Json::Value tmp;
        
        tmp[p_exception_identifier + p_seperation_token + std::to_string(id)]["id"]        = exception.id;
        tmp[p_exception_identifier + p_seperation_token + std::to_string(id)]["type"]      = exception.type;
        tmp[p_exception_identifier + p_seperation_token + std::to_string(id)]["location"]  = exception.location;
        tmp[p_exception_identifier + p_seperation_token + std::to_string(id)]["file"]      = exception.file;
        
        root.append(tmp);
        id++;
    }
    
    out_file << root;
    out_file.close();
}
